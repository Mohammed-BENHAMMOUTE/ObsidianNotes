SOLID is a set of five principles that help me write clean, flexible, and maintainable code.

---

### ðŸ”¹ **S â€“ Single Responsibility Principle (SRP)**

- A class should have **only one reason to change**.
    
- Each class should focus on **one task or responsibility**.
    
- âœ… Makes code easier to read, maintain, and test.
    
- ðŸ§  _Example_: Separate a class that generates reports from the one that saves them.

---

### ðŸ”¹ **O â€“ Open/Closed Principle (OCP)**

- Classes should be **open for extension but closed for modification**.
    
- You should be able to add new behavior without changing existing code.
    
- âœ… Helps avoid breaking working code when adding features.
    
- ðŸ§  _Example_: Use interfaces or inheritance to support new types without altering core logic.
    

---

### ðŸ”¹ **L â€“ Liskov Substitution Principle (LSP)**

- Subclasses should be **replaceable** for their parent classes **without breaking the program**.
    
- âœ… Ensures that inheritance is used correctly.
    
- ðŸ§  _Example_: Donâ€™t make a `Penguin` subclass of `Bird` if it canâ€™t `fly()` like other birds.
    

---

### ðŸ”¹ **I â€“ Interface Segregation Principle (ISP)**

- No class should be forced to **depend on methods it doesnâ€™t use**.
    
- Split large interfaces into smaller, more specific ones.
    
- âœ… Leads to better modularity and less unnecessary code.
    
- ðŸ§  _Example_: Instead of one big `Machine` interface with `print()`, `scan()`, and `fax()`, use separate `Printable`, `Scannable`, and `Faxable` interfaces.
    

---

### ðŸ”¹ **D â€“ Dependency Inversion Principle (DIP)**

- High-level modules should **not depend on low-level modules**.
    
- Both should depend on **abstractions** (interfaces).
    
- âœ… Promotes loose coupling and easier testing.
    
- ðŸ§  _Example_: A service should depend on a `DatabaseInterface`, not a concrete `MySQLDatabase`.

In typical code, high-level classes (like business logic) often depend directly on low-level classes (like database or file handlers). That creates **tight coupling** and makes the system:

- Hard to modify
    
- Hard to test
    
- Not reusable
    

DIP solves this by introducing an **interface** or **abstract class** that sits between them.

In typical code, high-level classes (like business logic) often depend directly on low-level classes (like database or file handlers). That creates **tight coupling** and makes the system:

- Hard to modify
    
- Hard to test
    
- Not reusable
    

DIP solves this by introducing an **interface** or **abstract class** that sits between them.




---
