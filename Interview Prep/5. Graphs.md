# Graph Theory Knowledge Summary

## Basic Concepts
- **Graph**: A collection of vertices (nodes) connected by edges
- **Directed Graph**: Edges have direction (one-way)  
- **Undirected Graph**: Edges have no direction (two-way)
- **Weighted Graph**: Edges have weights/costs
- **Representation**: Adjacency matrix (O(V²) space) or adjacency list (O(V+E) space)

## Graph Traversal
- **Depth-First Search (DFS)**: Uses stack, explores as far as possible before backtracking, O(V+E)
- **Breadth-First Search (BFS)**: Uses queue, explores all neighbors before moving to next level, O(V+E)
- **Applications**: Connected components, cycle detection, topological sorting

## Shortest Path Algorithms
- **Dijkstra's Algorithm**: For graphs with non-negative edge weights, O((V+E)log V) with priority queue
- **Bellman-Ford**: Handles negative weights, detects negative cycles, O(V×E)
- **Floyd-Warshall**: All-pairs shortest paths, O(V³)
- **0-1 BFS**: For graphs with edge weights of only 0 or 1, O(V+E)

## Minimum Spanning Tree (MST)
- **Kruskal's Algorithm**: Sort edges by weight, add if no cycle formed, O(E log E)
- **Prim's Algorithm**: Start from one vertex, grow tree by adding cheapest edge, O(E log V) with binary heap
- **Applications**: Network design, clustering, approximating TSP

## Advanced Graph Algorithms
- **Topological Sort**: Linear ordering of vertices in DAG, O(V+E)
- **Strongly Connected Components**:
  - **Kosaraju's Algorithm**: Two DFS passes, O(V+E)
  - **Tarjan's Algorithm**: Single DFS pass, O(V+E)
- **Articulation Points & Bridges**: Identifies critical nodes/edges, O(V+E)

## Maximum Flow
- **Ford-Fulkerson Algorithm**: Augmenting paths approach, O(E×max_flow)
- **Edmonds-Karp**: Ford-Fulkerson with BFS, O(V×E²)
- **Dinic's Algorithm**: Level graphs for blocking flows, O(V²×E)

## Bipartite Graphs
- **Matching Problems**: Maximum bipartite matching using Ford-Fulkerson, O(V×E)
- **Hopcroft-Karp Algorithm**: Improved bipartite matching, O(E√V)

## Tree Algorithms
- **Lowest Common Ancestor (LCA)**: 
  - Binary lifting technique, O(log V) per query after O(V log V) preprocessing
  - Euler tour + RMQ, O(1) per query after O(V) preprocessing

## Competitive Programming Applications
- **Problem patterns**: Graph transformation, implicit graphs
- **Shortest path variants**: K-shortest paths, conditional paths
- **Dynamic programming on graphs**: State compression
- **Network flow applications**: Bipartite matching, min-cut, circulation problems