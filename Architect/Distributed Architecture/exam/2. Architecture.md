---
aliases:
---

+ we choose an event driven micro services.

1. can we use a monolith? for this application? 

![[Pasted image 20250526084119.png]]
not really

2. Service Based architecture:
![[Pasted image 20250526084158.png]]
very poor elasticity and a limited scalability, couplage fort, manque de reactivite. risque de securite: Les données sensibles (paiements) ne seraient pas isolées, augmentant les vulnérabilités.

3. Event Driven
![[Pasted image 20250526085106.png]]

+ **Latence inacceptable** : Certaines actions (ex : confirmation immédiate de réservation) nécessitent des réponses synchrones, difficiles à garantir avec un modèle 100% asynchrone.
+ **Complexité des transactions** : Gérer des workflows critiques (ex : paiement → réservation) avec des événements purs impose une logique de compensation complexe (Saga), augmentant les risques d’incohérences.
+ **Surcoût d’infrastructure** : Un bus d’événements (Kafka) pour _toutes_ les interactions serait coûteux et surdimensionné pour des tâches simples (ex : CRUD d’événements).
+ **Difficulté de débogage** : Tracer des erreurs dans un système entièrement asynchrone est complexe (manque de visibilité sur l’état global).
+ **Expérience utilisateur dégradée** : Les délais inhérents aux événements asynchrones pourraient ralentir des processus critiques (ex : validation de carte bancaire).

3. Space based architecture
	1. **Cohérence des données problématique** : La réplication en mémoire des données entraîne des risques de surréservations (ex : deux utilisateurs réservent le dernier billet simultanément).
	    
	2. **Complexité des transactions temps réel** : Les confirmations immédiates de réservation nécessitent une cohérence forte, difficile à garantir avec un modèle distribué asynchrone.
	    
	3. **Intégration limitée avec les tiers** : Les services externes (paiement, streaming) sont moins compatibles avec une grille de traitement en mémoire, nécessitant des adaptations coûteuses.
	    
	4. **Coûts d’infrastructure élevés** : Une grille distribuée exige des ressources matérielles massives pour gérer des pics de trafic, contrairement aux microservices cloud-natifs.
	    
	5. **Maintenance complexe** : Déboguer des incohérences dans un espace partagé est ardu, surtout lors de fusions ou de mises à jour fréquentes.


4.SOA:
		Une architecture **SOA (Service-Oriented Architecture)** est inadaptée pour ce projet car :


+  **Granularité trop grossière** : Les services SOA sont monolithiques et lourds, limitant la scalabilité fine requise pour gérer des pics de trafic (ex : 100k réservations simultanées).
    
+  **Goulet d’étranglement de l’ESB** : Le bus d’entreprise (ESB) centralisé ralentit les communications temps réel et devient un point de défaillance critique.
    
+  **Couplage résiduel** : Les services partagent des dépendances via l’ESB, rendant les mises à jour complexes et risquant des cascades d’erreurs (ex : un échec de paiement bloque les réservations).
    
+  **Manque de réactivité asynchrone** : Le modèle SOA repose sur des appels synchrones (SOAP/REST), inadaptés aux flux événementiels (notifications, streaming) nécessitant un traitement asynchrone.
    
+  **Gouvernance rigide** : La standardisation stricte des contrats SOA ralentit l’intégration de technologies hétérogènes (ex : WebRTC, Stripe) et l’adaptation aux fusions d’entreprises.
    
+  **Coûts opérationnels élevés** : Déployer/maintenir un ESB et des services monolithiques est coûteux comparé aux microservices cloud-natifs.


5.Microservices architecture:

Une architecture **Microservices "pure" (sans composant événementiel)** est insuffisante pour ce projet car :

1. **Goulots d’étranglement synchrones** : Les appels REST/HTTP entre services bloquent les threads, limitant le débit lors de pics de trafic (ex : 100k réservations simultanées).
    
2. **Cohérence des données fragile** : Sans bus d’événements, synchroniser les états (ex : disponibilités, paiements) nécessite des appels directs complexes, risquant des incohérences (ex : surréservations).
    
3. **Résilience limitée** : Les dépendances synchrones entraînent des cascades de défaillances (ex : panne du service de paiement → blocage de toutes les réservations).
    
4. **Latence inadaptée au temps réel** : Les interactions critiques (notifications, streaming) exigent un modèle asynchrone pour une réactivité optimale.
    
5. **Scalabilité inefficace** : Scaliner un service (ex : réservations) sans orchestrer les dépendances (paiement, notifications) crée des déséquilibres.



## 6. Event driven microservices?
why does it work:
Les **Microservices Événementiels** combinent :

- La **scalabilité granulaire** des microservices.
    
- La **résilience** et **réactivité** de l’asynchronisme.
    
- La **cohérence des données** via des patterns comme les Sagas et CQRS.
    
- La **flexibilité** d’intégrer des technologies hétérogènes 